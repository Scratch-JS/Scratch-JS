<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Sprite.html">Sprite</a><ul class='methods'><li data-type='method'><a href="Sprite.html#changeCostume">changeCostume</a></li><li data-type='method'><a href="Sprite.html#changeXBy">changeXBy</a></li><li data-type='method'><a href="Sprite.html#changeYBy">changeYBy</a></li><li data-type='method'><a href="Sprite.html#distanceTo">distanceTo</a></li><li data-type='method'><a href="Sprite.html#glideTo">glideTo</a></li><li data-type='method'><a href="Sprite.html#goTo">goTo</a></li><li data-type='method'><a href="Sprite.html#hide">hide</a></li><li data-type='method'><a href="Sprite.html#move">move</a></li><li data-type='method'><a href="Sprite.html#pointInDirection">pointInDirection</a></li><li data-type='method'><a href="Sprite.html#resize">resize</a></li><li data-type='method'><a href="Sprite.html#setXTo">setXTo</a></li><li data-type='method'><a href="Sprite.html#setYTo">setYTo</a></li><li data-type='method'><a href="Sprite.html#show">show</a></li><li data-type='method'><a href="Sprite.html#turn">turn</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="mouse.html">mouse</a><ul class='methods'><li data-type='method'><a href="mouse.html#.setCostume">setCostume</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#ask">ask</a></li><li><a href="global.html#forever">forever</a></li><li><a href="global.html#repeat">repeat</a></li><li><a href="global.html#say">say</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#wait">wait</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>//define and initialize global sprites array that every sprite pushes itself to
var spritesArray = [];

/**
 * Creates a new Scratch-JS sprite and adds it to the stage
 * @param {Number} x starting x position of the sprite
 * @param {Number} y starting y position of the sprite
 * @param {String} value sprite image file name or HTML tag
 * @param {Number} [scaleFactor] Optionally scale an image sprite by a scale factor (0-1)
 * @constructor
 */
function Sprite(x, y, value, scaleFactor) {
    /*Sprite methods*/

    //updates both x and y
    this.updateLocation = function () {
        this.element.style.left = (page.originOffsetX + this.x - (this.element.clientWidth / 2)) + "px";
        this.element.style.top = (page.originOffsetY - this.y - (this.element.clientHeight / 2)) + "px";
    };

    //updates only x
    this.updateX = function () {
        this.element.style.left = (page.originOffsetX + this.x - (this.element.clientWidth / 2)) + "px";
    };

    //updates only y
    this.updateY = function () {
        this.element.style.top = (page.originOffsetY - this.y - (this.element.clientHeight / 2)) + "px";
    };

    this.updateRotation = function () {
        //by default turns clockwise, added "-" to make it turn counterclockwise like in geometry
        this.element.style.transform = "rotate(" + (this.direction * -1) + "deg)";
    };

    /**
     * Scales a sprite by a scale factor
     * @param {Number} scaleFactor A scale factor from 0-1
     */
    this.resize = function (scaleFactor) {
        var originalWidth = this.element.clientWidth;
        this.element.width = originalWidth * scaleFactor;
    };

    /**
     * !!!!ADD PARAMETERS MANUALLY!!!! Go to another sprite or an x,y coordinate. Takes either 1 parameter (a sprite) or 2 parameters (the x,y coordinates)
     */
    this.goTo = function () {
        if (arguments[1] != undefined) {
            //two arguments provided, the arguments are expected to be x and y respectively. go to this x and y position
            this.x = arguments[0];
            this.y = arguments[1];
            this.updateLocation();
        } else if (arguments[0]) {
            //only one argument provided, expected to be sprite. go to that sprites position
            var spriteToGoTo = arguments[0];
            this.x = spriteToGoTo.x;
            this.y = spriteToGoTo.y;
            this.updateLocation();
        }
    };


    /**
     * Moves the sprite to a certain x position
     * @param {Number} newX The new x value
     */
    this.setXTo = function (newX) {
        this.x = newX;
        this.updateX();
    };

    /**
     * Moves the sprite to a certain y position
     * @param {Number} newY The new y value
     */
    this.setYTo = function (newY) {
        this.y = newY;
        this.updateY();
    };

    /**
     * Changes the x position of the sprite
     * @param {Number} deltaX The amount to change x
     */
    this.changeXBy = function (deltaX) {
        this.x += deltaX;
        this.updateX();
    };

    /**
     * Changes the y position of the sprite
     * @param {Number} deltaY The amount to change y
     */
    this.changeYBy = function (deltaY) {
        this.y += deltaY;
        this.updateY();
    };

    /**
     * Turns the sprite counter clockwise
     * @param {Number} degrees The amount of degrees to turn the sprite
     */
    this.turn = function (degrees) {
        this.direction += degrees;
        this.updateRotation();
    };

    /**
     * !!!!ADD PARAMETERS MANUALLY!!!! Points the sprite towards another sprite or a certain angle (right 0, up 90). Parameter: direction: angle, can be negative, or sprite: sprite to point towards
     */
    this.pointInDirection = function () {
        if (arguments[0] instanceof Sprite) { //if the argument is a sprite
            //calculate the angle between this sprite and the sprite in the argument
            var sprite = arguments[0];
            var deltaX = sprite.x - this.x;
            var deltaY = sprite.y - this.y;
            this.direction = Math.atan2(deltaY, deltaX) * (180 / Math.PI);
        } else {
            this.direction = arguments[0];
        }
        this.updateRotation();
    };

    /**
     * Moves the sprite in the direction it's facing
     * @param amount Amount to move the sprite (in pixels)
     */
    this.move = function (amount) {
        var deltaX = Math.cos(this.direction * Math.PI / 180) * amount;
        var deltaY = Math.sin(this.direction * Math.PI / 180) * amount;
        this.x += deltaX;
        this.y += deltaY;
        this.updateLocation();
    };

    var calculateDistance = function (x1, y1, x2, y2) {
        //simple pythagorean theorem to find distance between points
        return Math.sqrt(((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2)));
    };

    /**
     * !!!!ADD PARAMETERS MANUALLY!!!! Calculates the distance between this sprite and x,y coordinates or another sprite
     * Parameters:
     * usage 1: x, y
     * usage 2: sprite - another sprite
     */
    this.distanceTo = function () {
        if (arguments[1] != undefined) {
            //if two arguments are provided the two arguments must be x, y coordinates
            return calculateDistance(this.x, this.y, arguments[0], arguments[1]);
        } else {
            //if only one argument, argument must be a sprite
            return calculateDistance(this.x, this.y, arguments[0].x, arguments[0].y)
        }
    };

    /**
     * Shows a hidden sprite
     */
    this.show = function () {
        this.element.style.display = "initial";
        this.isHidden = false;
    };

    /**
     * Hides a sprite
     */
    this.hide = function () {
        this.element.style.display = "none";
        this.isHidden = true;
    };

    /**
     * !!!!ADD PARAMETERS MANUALLY!!!! Glides to an x,y coordinate or another sprite for a certain amount of time
     * Parameters:
     * usage 1: x, y, time
     * usage 2: sprite, time
     * @returns {Promise}
     */
    this.glideTo = function () {
        var length;
        var y;
        var x;
        var argumentsAreCoordinates = arguments[2] !== undefined;
        if (argumentsAreCoordinates) {
            x = arguments[0];
            y = arguments[1];
            length = arguments[2];
        } else {
            x = arguments[0].x;
            y = arguments[0].y;
            length = arguments[1];
        }
        this.element.style.transition = "left " + length + "ms linear, top " + length + "ms linear";
        wait(1).then(function () {
            thisReference.goTo(x, y);
        });
        return new Promise(function (resolve) {
            setTimeout(function () {
                //After animation finishes, reset the sprites transition property
                thisReference.element.style.transition = "left 0ms, top 0ms";
                //resolve the promise
                resolve();
            }, length);
        });
    };

    /**
     * Changes the sprites costume
     * @param {String} newCostume The new costume (can be an image, or HTML tag)
     */
    this.changeCostume = function (newCostume) {
        var containingDiv;
        var valueIsHtmlTag = (/&lt;(br|basefont|hr|input|source|frame|param|area|meta|!--|col|link|option|base|img|wbr|!DOCTYPE).*?>|&lt;(a|abbr|acronym|address|applet|article|aside|audio|b|bdi|bdo|big|blockquote|body|button|canvas|caption|center|cite|code|colgroup|command|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|em|embed|fieldset|figcaption|figure|font|footer|form|frameset|head|header|hgroup|h1|h2|h3|h4|h5|h6|html|i|iframe|ins|kbd|keygen|label|legend|li|map|mark|menu|meter|nav|noframes|noscript|object|ol|optgroup|output|p|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|span|strike|strong|style|sub|summary|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video).*?&lt;\/\2>/i.test(newCostume));
        if (!valueIsHtmlTag &amp;&amp; this.isImage) {
            //Old sprite is image, new sprite is also image
            this.element.src = newCostume;
            this.isImage = true;
        } else if (valueIsHtmlTag &amp;&amp; this.isImage) {
            //Old sprite is image, new sprite is not
            document.body.removeChild(this.element);
            containingDiv = document.createElement("div");
            containingDiv.innerHTML = newCostume;
            this.element = containingDiv.firstChild;
            this.updateLocation();
            document.body.appendChild(containingDiv);
            this.isImage = false;
        } else if (valueIsHtmlTag &amp;&amp; !this.isImage) {
            //Old sprite is not an image, new one is also not image
            containingDiv = this.element.parentNode;
            containingDiv.innerHTML = newCostume;
            this.element = containingDiv.firstChild;
            this.updateLocation();
            this.isImage = false;
        } else if (!valueIsHtmlTag &amp;&amp; !this.isImage) {
            //Old sprite is not an image, new one is an image
            document.body.removeChild(this.element.parentNode);
            this.element = document.createElement("img");
            this.element.src = newCostume;
            this.updateLocation();
            document.body.appendChild(this.element);
            this.isImage = true;
        }
    };

    /*Sprite Initialisation*/
    this.x = x;
    this.y = y;
    this.direction = 0;
    this.isHidden = false;
    spritesArray.push(this);
    //Sometimes this get changed inside other scopes, so using another variable as reference
    var thisReference = this;

    var valueIsHtmlTag = (/&lt;(br|basefont|hr|input|source|frame|param|area|meta|!--|col|link|option|base|img|wbr|!DOCTYPE).*?>|&lt;(a|abbr|acronym|address|applet|article|aside|audio|b|bdi|bdo|big|blockquote|body|button|canvas|caption|center|cite|code|colgroup|command|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|em|embed|fieldset|figcaption|figure|font|footer|form|frameset|head|header|hgroup|h1|h2|h3|h4|h5|h6|html|i|iframe|ins|kbd|keygen|label|legend|li|map|mark|menu|meter|nav|noframes|noscript|object|ol|optgroup|output|p|pre|progress|q|rp|rt|ruby|s|samp|script|section|select|small|span|strike|strong|style|sub|summary|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video).*?&lt;\/\2>/i.test(value));
    if (valueIsHtmlTag) {
        //if value is an html tag name
        var containingDiv = document.createElement("div");
        containingDiv.innerHTML = value;
        this.element = containingDiv.firstChild;
        this.updateLocation();
        document.body.appendChild(containingDiv);
        this.isImage = false;
    } else {
        //value is not html or error so custom sprite, use value as img src
        this.element = document.createElement("img");
        this.element.src = value;
        document.body.appendChild(this.element);
        this.element.style.visibility = "hidden";

        var that = this;

        this.element.onload = function () {
            //if size argument found, set it
            if (scaleFactor) {
                thisReference.resize(scaleFactor);
            }

            that.updateLocation();
            that.isImage = true;
            that.element.style.visibility = "initial";
        }
    }
}

/*Global Scratch-JS Functions*/

/**
 * Repeat a block of code (callback)
 * @param {Number} times The amount of times to repeat it
 * @param {Function} callback The block of code
 */
function repeat(times, callback) {
    for (var i = 0; i &lt; times; i++) {
        callback();
    }
}

/**
 * Waits and then executes the code in the "then" block
 * @param {Number} length Time in milliseconds
 * @returns {Promise}
 */
function wait(length) {
    return new Promise(function (resolve) {
        setTimeout(function () {
            resolve();
        }, length)
    });
}

/**
 * Executes a block (callback) forever until the stop function is called
 * @param {Function} callback The block of code to execute forever
 * @returns {number} An optional id that can be used by stop() to stop the forever
 */
function forever(callback) {
    return setInterval(function () {
        callback();
    }, 1);
}

/**
 * Stops a forever
 * @param {Number} intervalToStop The id of the forever to stop
 */
function stop(intervalToStop) {
    clearInterval(intervalToStop);
}

/**
 * Say something (uses JavaScript alert)
 * @param {String} text
 */
function say(text) {
    alert(text);
}

/**
 * Asks something (uses JavaScript prompt)
 * @param {String} text
 */
function ask(text) {
    return prompt(text);
}


/*Mouse Stuff*/

/**
 * @namespace
 * @property {Boolean} ready - Whether the mouse is ready
 */
var mouse = {
    ready: false
};

/**
 * Set the mouse costume (image or any valid CSS mouse pointer)
 * @param {String} costumeName Image or CSS mouse pointer name
 */
mouse.setCostume = function (costumeName) {
    var mouseSprite;
    var args = arguments;
    var isCustom = !(/alias|all-scroll|auto|cell|context-menu|col-resize|copy|crosshair|default|e-resize|ew-resize|grab|grabbing|help|move|n-resize|ne-resize|nesw-resize|ns-resize|nw-resize|nwse-resize|no-drop|none|not-allowed|pointer|progress|row-resize|s-resize|se-resize|sw-resize|text|vertical-text|w-resize|wait|zoom-in|zoom-out|initial/).test(costumeName);
    if (isCustom) {
        //if new costume is custom, make the real cursor hidden everywhere
        document.body.style.cursor = "none";
        //make it hidden when on top of other elements
        for (var i = 0; i &lt; document.body.getElementsByTagName("*").length; i++) {
            document.body.getElementsByTagName("*")[i].style.cursor = "none";
        }
        //When we get the mouse coordinates, create our fake mouse
        var checkMouseReady = forever(function () {
            if (mouse.ready) {
                //stop checking for the mouse.ready
                stop(checkMouseReady);
                //If size argument is included pass it on when creating the fake mouse's sprite
                if (args[1] !== undefined) {
                    //create the fake mouse without a size argument
                    mouseSprite = new Sprite(0, 0, costumeName, args[1]);
                } else {
                    //create the fake mouse without a size argument
                    mouseSprite = new Sprite(0, 0, costumeName);
                }
                //javascript doesn't let me modify this directly so I use a css id to get around it
                mouseSprite.element.id = "cursorImage";
                //make sure that dragging the mouse doesn't drag the mouse sprite
                mouseSprite.element.draggable = "none";
                //Forever go to the mouse
                forever(function () {
                    mouseSprite.goTo(mouse);
                })
            }
        });
    } else {
        //If it's not a custom sprite, change the cursor to the cursor type provided as a parameter
        document.body.style.cursor = costumeName;
    }
};

document.onmousemove = function () {
    mouse.x = event.x - page.originOffsetX;
    mouse.y = page.originOffsetY - event.y;
    mouse.ready = true;
};

/*Stage and DOM Initialization*/
var whenPageLoads = function () {
};
var page = {};
var bodyDiv;
window.onload = function () {
    page.originOffsetX = window.innerWidth / 2;
    page.originOffsetY = window.innerHeight / 2;
    page.maxX = page.originOffsetX;
    page.maxY = page.originOffsetY;
    bodyDiv = document.createElement("div");
    bodyDiv.style.width = page.originOffsetX * 2 + "px";
    bodyDiv.style.height = page.originOffsetY * 2 + "px";
    bodyDiv.style.left = "0px";
    document.body.appendChild(bodyDiv);

    //add styles
    var style = document.createElement("style");
    style.innerHTML = "* { position: absolute; } body { margin: 0; opacity: 0; overflow: hidden; } #cursorImage { pointer-events: none }";
    document.getElementsByTagName('head')[0].appendChild(style);

    transpileCode();

    whenCodeLoads = function () {
        document.body.style.opacity = "1";
        whenPageLoads();
    }
};

window.onresize = function () {
    page.originOffsetX = window.innerWidth / 2;
    page.originOffsetY = window.innerHeight / 2;
    page.maxX = page.originOffsetX;
    page.maxY = page.originOffsetY;
    for (var spriteIndex in spritesArray) {
        spritesArray[spriteIndex].updateLocation();
    }
    bodyDiv.style.width = page.originOffsetX * 2 + "px";
    bodyDiv.style.height = page.originOffsetY * 2 + "px";
};


/*Transpiler*/
function whenCodeLoads() {
}

function transpileCode() {
    if (location.protocol === "file:") {
        //If page is served through local file system, fail gracefully
        console.error("Scratch-JS accessed through file:// Please run an localhost server and access it through http:// (default: localhost:8000)");
    } else {
        //Otherwise, do everything normally
        var request = new XMLHttpRequest();
        request.open("GET", "index.sjs");
        request.send();
        //when ready state changes and the new state, shows success, get the code and store it in the code variable
        request.onreadystatechange = function () {
            if (request.readyState === 4 &amp;&amp; request.status == 200) {
                var code = request.responseText;
                //transpile SJS anonymous functions and SJS callbacks
                code = transpileAnonymousFunctions(transpileCallbacks(code, 0));
                eval(code);
                whenCodeLoads();
            }
        };
    }
}

function transpileCallbacks(code, currentIndex) {
    if (code.includes("({")) {
        var indexOfCallback = code.indexOf("({", currentIndex) + 1;
        //preform the replacement using insert (defined in polyfills)
        code = code.insert(indexOfCallback, "function()");
        return transpileCallbacks(code, indexOfCallback + 1);
    } else {
        return code;
    }
}

function transpileAnonymousFunctions(code) {
    //REGEX checks if { exists after the end boundary of a word (with optional whitespace in between)
    return code.replace(/\b\s*\{/g, "=function(){");
}


/*Polyfills*/

//String.prototype.includes pollyfill
if (!String.prototype.includes) {
    String.prototype.includes = function (search, start) {
        'use strict';
        if (typeof start !== 'number') {
            start = 0;
        }

        if (start + search.length > this.length) {
            return false;
        } else {
            return this.indexOf(search, start) !== -1;
        }
    };
}

String.prototype.insert = function (index, stringToAdd) {
    return this.slice(0, index) + stringToAdd + this.slice(index);
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Nov 30 2016 15:26:26 GMT-0500 (EST) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
